<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Tower Defense Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #111;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 20px auto;
      background: #222;
      border: none;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }
    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: #FFFFFF;
      font-size: 18px;
      font-family: 'Roboto', sans-serif;
      text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.8);
    }
    .score, .time {
      margin: 10px 0;
    }
    .level-bar {
      width: 200px;
      height: 20px;
      background: #444;
      border-radius: 10px;
      margin: 10px 0;
    }
    .level-bar span {
      display: block;
      height: 100%;
      background: linear-gradient(45deg, #00ff99, #00ccff);
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <div id="ui">
    <div class="score">Score: <span id="scoreCounter">0</span></div>
    <div class="time">Time Remaining: <span id="timeCounter">60</span>s</div>
    <div class="level-bar">
      <span id="levelProgress"></span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game State Variables
    let score = 0;
    let enemiesRemaining = 10;
    let gameTime = 60; // Start the countdown at 60 seconds
    let levelProgress = 0;

    // Enemy path points
    const path = [
      { x: 0, y: 300 },
      { x: 200, y: 300 },
      { x: 200, y: 500 },
      { x: 600, y: 500 },
      { x: 600, y: 100 },
      { x: 800, y: 100 }
    ];

    // Countdown timer
    function updateTime() {
      if (gameTime > 0) {
        gameTime--;
        document.getElementById('timeCounter').textContent = gameTime;
      } else {
        alert("Game Over! Time's up!");
        clearInterval(updateTime);
      }
    }

    setInterval(updateTime, 1000);

    // Draw enemy path
    function drawPath() {
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(path[0].x, path[0].y);
      for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
      }
      ctx.stroke();
    }

    // Basic Tower Class
    class Tower {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.range = 100;
        this.level = 1;
        this.fireRate = 60;
        this.cooldown = 0;
        this.cost = 50;
        this.upgraded = false;
        this.type = 'handgun';
      }
      upgrade() {
        if (score >= 50) {
          this.level++;
          this.range += 20;
          this.fireRate = 45;
          score -= 50;
        }
      }
      update() {
        if (this.cooldown > 0) {
          this.cooldown--;
        } else {
          let target = enemies.find(e => {
            const dx = e.x - this.x;
            const dy = e.y - this.y;
            return Math.sqrt(dx * dx + dy * dy) < this.range && e.alive;
          });
          if (target) {
            projectiles.push(new Projectile(this.x, this.y, target));
            this.cooldown = this.fireRate;
          }
        }
      }
      draw() {
        ctx.fillStyle = '#00FF99'; // Neon green for tower
        ctx.beginPath();
        ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Projectile Class (with particle effects)
    class Projectile {
      constructor(x, y, target) {
        this.x = x;
        this.y = y;
        this.target = target;
        this.speed = 4;
        this.alive = true;
      }

      update() {
        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < this.speed) {
          this.target.alive = false;
          score += 10;
          enemiesRemaining--;
          this.alive = false;
        } else {
          this.x += (dx / dist) * this.speed;
          this.y += (dy / dist) * this.speed;
        }
      }

      draw() {
        ctx.fillStyle = '#FF5722'; // Bright red projectiles
        ctx.beginPath();
        ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Enemy Class (with smooth movement)
    class Enemy {
      constructor() {
        this.radius = 10;
        this.health = 100;
        this.speed = 1;
        this.x = path[0].x;
        this.y = path[0].y;
        this.currentPoint = 1;
        this.alive = true;
      }

      update() {
        if (this.currentPoint >= path.length) return;

        const target = path[this.currentPoint];
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < this.speed) {
          this.x = target.x;
          this.y = target.y;
          this.currentPoint++;
        } else {
          this.x += (dx / dist) * this.speed;
          this.y += (dy / dist) * this.speed;
        }
      }

      draw() {
        ctx.fillStyle = '#FF6347'; // Tomato color for enemies
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Update the UI
    function updateUI() {
      document.getElementById('scoreCounter').textContent = score;
      document.getElementById('enemyCounter').textContent = enemiesRemaining;
      const progress = Math.max(0, (score / 100) * 100);
      document.getElementById('levelProgress').style.width = `${progress}%`;
    }

    // Game loop
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw the enemy path
      drawPath();  // Draw path

      // Update game objects
      enemies.forEach(e => e.update());
      towers.forEach(t => t.update());
      projectiles.forEach(p => p.update());

      // Remove dead enemies and projectiles
      enemies.filter(e => e.alive);
      projectiles.filter(p => p.alive);

      // Draw game objects
      enemies.forEach(e => e.draw());
      towers.forEach(t => t.draw());
      projectiles.forEach(p => p.draw());

      updateUI();  // Update score/time
      requestAnimationFrame(gameLoop);
    }

    // Start the game
    function startGame() {
      setInterval(() => {
        if (enemiesRemaining > 0) {
          enemies.push(new Enemy());
        }
      }, 3000); // spawn new enemy every 3 seconds

      gameLoop();
    }

    // User interaction (place towers)
    canvas.addEventListener('click', function(event) {
      const x = event.clientX - canvas.offsetLeft;
      const y = event.clientY - canvas.offsetTop;

      let towerFound = false;
      for (let tower of towers) {
        const dx = tower.x - x;
        const dy = tower.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 20) {
          towerFound = true;
          tower.upgrade();
          break;
        }
      }

      if (!towerFound) {
        towers.push(new Tower(x, y));
      }
    });

    startGame();
  </script>
</body>
</html>
